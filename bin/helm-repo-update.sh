#!/bin/bash

set -eou pipefail

# This script requires Linux and bash to run
if [[ "$(uname -s)" != "Linux" ]]; then
  echo "Error: This script must be run on Linux"
  echo "Current OS: $(uname -s)"
  echo "This script uses GNU sed which is not compatible with BSD sed (macOS)"
  exit 1
fi

# Ensure we're running in bash
if [[ -z "$BASH_VERSION" ]]; then
  echo "Error: This script must be run in bash"
  echo "Current shell: $SHELL"
  echo "This script uses bash-specific features and syntax"
  exit 1
fi

for program in helm tar yq git; do
  if ! command -v "$program" >/dev/null; then
    echo "Error: Required program '$program' is not installed or not in PATH"
    echo "Please install $program and try again"
    exit 1
  fi
done

helm_version_full=$(helm version --template="{{.Version}}" | sed 's/^v//')
helm_version=$(echo "$helm_version_full" | awk -F. '{printf "%d%02d%02d", $1, $2, $3}')

if [ "$helm_version" -lt "30800" ] ; then
  echo "Error: Helm version must be >= 3.8.0 (found: $helm_version_full)"
  exit 1
fi

function ARGFAIL() {
  echo -n "
Usage $0 [OPTIONS]:
  --update-helm-chart       Update specific helm chart      [Need path to specific helm chart]
  --update-all              Update all the helm chart       [Default: false]
  --actions                 Run inside a GitHub or Gitea Action   [Default: false] (Only in CI)
  --skip-charts             Skip updating certain charts    [Default: none]
  --chart-version           Helm chart version              [Default: latest]
  -h|--help

Example:
# $0 --update-helm-chart traefik
# $0 --update-all --skip-charts 'aws-efs-csi-driver,capi-cluster,grafana-operator,strimzi-kafka-operator'
"
}

declare UPDATE_ALL=false
declare ACTIONS=false
declare UPDATE_HELM_CHART=
declare SKIP_CHARTS=
declare ARGOCD_CHART_PATH="argocd-helm-charts"
declare HELM_VERSION_LAST_UPDATE="./.helm_version_last_update"
declare CHART_VERSION=

# Arrays to track updates
declare -a MINOR_UPDATES
declare -a PATCH_UPDATES
declare -a MAJOR_UPDATES

# Flags to track highest version bump needed
HAS_MAJOR=false
HAS_MINOR=false
HAS_PATCH=false

[ $# -eq 0 ] && { ARGFAIL; exit 1; }

while [[ $# -gt 0 ]]; do
  arg="$1"
  shift

  case "$arg" in
    --update-all)
      UPDATE_ALL=true
      ;;
    --update-helm-chart)
      if [[ $# -eq 0 || "$1" =~ ^-- ]]; then
        echo "Error: --update-helm-chart requires a chart name"
        ARGFAIL
        exit 1
      fi

      UPDATE_HELM_CHART=$1

      if ! test -d "$ARGOCD_CHART_PATH/$UPDATE_HELM_CHART"; then
        echo "Chart ${UPDATE_HELM_CHART} under $ARGOCD_CHART_PATH dir does not exist, please make sure directory exists."
        exit 1
      fi

      shift
      ;;
    --actions)
      ACTIONS=true
      ;;
    --skip-charts)
      if [[ $# -gt 0 && ! "$1" =~ ^-- ]]; then
        SKIP_CHARTS=$1
        shift
      else
        echo "Warning: --skip-charts provided without value, skipping no charts"
      fi
      ;;
    --chart-version)
      if [[ $# -eq 0 || "$1" =~ ^-- ]]; then
        echo "Error: --chart-version requires a version number"
        ARGFAIL
        exit 1
      fi

      CHART_VERSION=$1

      shift
      ;;
    -h|--help)
      ARGFAIL
      exit
      ;;
    *)
      echo "Error: wrong argument given"
      ARGFAIL
      exit 1
      ;;
  esac
done

# Build an array based on the input (safe for empty values)
if [ -n "$SKIP_CHARTS" ]; then
  IFS=',' read -ra SKIP_HELM_CHARTS <<< "$SKIP_CHARTS"
else
  SKIP_HELM_CHARTS=()
fi

# Function to determine update type
function get_update_type() {
    local old_version=$1
    local new_version=$2

    local old_major
    local old_minor
    local old_patch

    local new_major
    local new_minor
    local new_patch

    # Remove 'v' prefix if present
    old_version=${old_version#v}
    new_version=${new_version#v}

    # Extract major, minor, patch
    old_major=$(echo "$old_version" | cut -d. -f1)
    old_minor=$(echo "$old_version" | cut -d. -f2)
    old_patch=$(echo "$old_version" | cut -d. -f3)

    new_major=$(echo "$new_version" | cut -d. -f1)
    new_minor=$(echo "$new_version" | cut -d. -f2)
    new_patch=$(echo "$new_version" | cut -d. -f3)

    # Compare versions
    if [[ "$new_major" -gt "$old_major" ]]; then
        echo "major"
    elif [[ "$new_major" -eq "$old_major" ]] && [[ "$new_minor" -gt "$old_minor" ]]; then
        echo "minor"
    elif [[ "$new_major" -eq "$old_major" ]] && [[ "$new_minor" -eq "$old_minor" ]] && [[ "$new_patch" -gt "$old_patch" ]]; then
        echo "patch"
    else
        echo "none"
    fi
}


# Function to bump version based on update type
# Note: semver tool is readily available as a package in linux
# with this we can survive with a small function and not a proud one.
function bump_version() {
    local version=$1
    local bump_type=$2

    # Remove 'v' prefix if present
    version=${version#v}

    IFS='.' read -ra VER <<< "$version"
    local major="${VER[0]}"
    local minor="${VER[1]}"
    local patch="${VER[2]}"

    case $bump_type in
        major)
            major=$((major + 1))
            minor=0
            patch=0
            ;;
        minor)
            minor=$((minor + 1))
            patch=0
            ;;
        patch)
            patch=$((patch + 1))
            ;;
    esac

    echo "${major}.${minor}.${patch}"
}

# Function to get current KubeAid version
function get_current_kubeaid_version() {
  git describe --tags --abbrev=0 2>/dev/null | sed 's/^v//' || echo "0.0.0"
}

# Function to compare two dates
function compare_dates() {
  local date1="$1"
  local date2="$2"
  local timestamp1
  local timestamp2

  # Convert dates to seconds since epoch for easy comparison
  timestamp1=$(date -d "$date1" +%s)
  timestamp2=$(date -d "$date2" +%s)

  # Perform comparisons
  [[ "$timestamp1" -gt "$timestamp2" ]]
}

# Function to find the date in the .helm_version_last_update file
# so we dont have to helm repo search, since it was update today locally
# on the node, so next re-run is faster
function get_last_update_date() {
  local repo

  repo="$1"

  # Note: we only need to check if chart is present or not, if someone add duplicate entry
  # it should not fail
  UPDATE_DATE=$(grep "$repo" "$CURRENT_DATE" | uniq | awk '{print $1}')
  if [ -z "$UPDATE_DATE" ]; then
    date -d "1 day ago" '+%Y-%m-%d'
  else
    echo "$UPDATE_DATE"
  fi
}

function add_last_update_date() {
  if [ "$(grep -c "${CURRENT_DATE} $HELM_CHART_NAME" "$HELM_VERSION_LAST_UPDATE")" -eq 0 ]; then
    echo "${CURRENT_DATE} $HELM_CHART_NAME" >> "$HELM_VERSION_LAST_UPDATE"
  else
    # Remove duplicate line if its present for any reason
    sed -i "0,/${CURRENT_DATE} $HELM_CHART_NAME/b; /${CURRENT_DATE} $HELM_CHART_NAME/d" "$HELM_VERSION_LAST_UPDATE"
  fi
}

function update_helm_chart {
  HELM_CHART_PATH="$ARGOCD_CHART_PATH/$1"
  HELM_CHART_YAML="$HELM_CHART_PATH/Chart.yaml"
  HELM_CHART_NEW_VERSION=$2

  # Exit if no chart.yaml is present
  if ! test -f "$HELM_CHART_YAML"; then
    echo "No $HELM_CHART_YAML present, please fix it"
    return
  fi

  HELM_REPO_NAME=$(yq eval '.name' "$HELM_CHART_YAML")
  HELM_CHART_DEP_PRESENT=$(yq eval '.dependencies | length' "$HELM_CHART_YAML")
  HELM_CHART_DEP_PATH="$HELM_CHART_PATH/charts"

  # This chart does not have any dependencies, so lets not do helm dep up
  if [ "$HELM_CHART_DEP_PRESENT" -ne 0 ]; then
    # It support helm chart updation for multiple dependencies
    # Iterate over each dependency and extract the desired values
    for ((i = 0; i < "$HELM_CHART_DEP_PRESENT"; i++)); do
      HELM_CHART_NAME=$(yq eval ".dependencies[$i].name" "$HELM_CHART_YAML")
      HELM_CHART_CURRENT_VERSION=$(yq eval ".dependencies[$i].version" "$HELM_CHART_YAML")
      HELM_REPOSITORY_URL=$(yq eval ".dependencies[$i].repository" "$HELM_CHART_YAML")

      local CURRENT_DATE
      local HELM_LAST_UPDATE_DATE

      CURRENT_DATE="$(date '+%Y-%m-%d')"
      HELM_LAST_UPDATE_DATE="$(get_last_update_date "$HELM_CHART_NAME")"

      if compare_dates "$HELM_LAST_UPDATE_DATE" "$CURRENT_DATE"; then
        # Add the repo
        if ! helm repo list -o yaml | yq eval -e ".[].name == \"$HELM_CHART_NAME\"" >/dev/null 2>&1; then
          echo "Adding Helm repository $HELM_REPOSITORY_URL"
          helm repo add "$HELM_CHART_NAME" "$HELM_REPOSITORY_URL" >/dev/null || {
            echo "Failed to add repository $HELM_REPOSITORY_URL for chart $HELM_CHART_NAME. Skipping."
            continue
          }
        fi

        # Check if we have an upstream chart already present or not
        if [ -z "$HELM_CHART_NEW_VERSION" ]; then
          HELM_CHART_NEW_VERSION=$(helm search repo --regexp "${HELM_CHART_NAME}/${HELM_CHART_NAME}[^-]" --version ">=$HELM_CHART_CURRENT_VERSION" --output yaml | yq eval '.[].version' -) || {
            echo "Failed to search for $HELM_CHART_NAME. Skipping."
            continue
          }
        fi
      else
        add_last_update_date
      fi

      # Compare the version of upstream chart and our local chart
      # if there is difference, run helm dep up or else skip
      if [ "$HELM_CHART_NEW_VERSION" != "$HELM_CHART_CURRENT_VERSION" ]; then
        local update_type
        update_type=$(get_update_type "$HELM_CHART_CURRENT_VERSION" "$HELM_CHART_NEW_VERSION")

        echo "HELMING $HELM_CHART_NAME"

        # Update the chart.yaml file
        yq eval -i ".dependencies[$i].version = \"$HELM_CHART_NEW_VERSION\"" "$HELM_CHART_YAML"

        # Go to helm chart, 1st layer
        helm dependencies update "$HELM_CHART_PATH" >/dev/null 2>&1 || {
          echo "Failed to update dependencies for $HELM_CHART_NAME"
          continue
        }

        # Deleting old helm before untar
        echo "Deleting old $HELM_CHART_NAME before untar"
        rm -rf "${HELM_CHART_DEP_PATH:?}/${HELM_CHART_NAME}" || {
          echo "Failed to update dependencies for $HELM_CHART_NAME. Skipping."
          continue
        }

        # rename the downloaded tar file so that it matches what we want during untar.
        # For example for strimzi kafka operator downloaded tar file has name strimzi-kafka-operator-helm-3-chart-0.38.0.tgz
        # while we look for strimzi-kafka-operator-0.38.0.tgz
        tar_file=$(find "$HELM_CHART_DEP_PATH" -maxdepth 1 -type f -name "*${HELM_CHART_NAME}*.tgz" -print -quit)
        expected_tar_file="$HELM_CHART_DEP_PATH/$HELM_CHART_NAME-$HELM_CHART_NEW_VERSION.tgz"

        # Check if the downloaded tar file matches the expected name
        if [ "$tar_file" != "$expected_tar_file" ]; then
            echo "Renaming $tar_file to $expected_tar_file"
            mv "$tar_file" "$expected_tar_file"
        fi

        # Untar the tgz file
        tar -C "$HELM_CHART_DEP_PATH" -xvf "$expected_tar_file" >/dev/null || {
          echo "Failed to extract $expected_tar_file. Skipping."
          continue
        }

        local update_line="- Updated $HELM_CHART_NAME from version $HELM_CHART_CURRENT_VERSION to $HELM_CHART_NEW_VERSION"

        case $update_type in
          major)
            MAJOR_UPDATES+=("$update_line")
            HAS_MAJOR=true
            ;;
          minor)
            MINOR_UPDATES+=("$update_line")
            if [ "$HAS_MAJOR" = false ]; then
              HAS_MINOR=true
            fi
            ;;
          patch)
            PATCH_UPDATES+=("$update_line")
            if [ "$HAS_MAJOR" = false ] && [ "$HAS_MINOR" = false ]; then
              HAS_PATCH=true
            fi
            ;;
        esac
      else
        echo "Helm chart $HELM_REPO_NAME is already on latest version $HELM_CHART_CURRENT_VERSION"
      fi
    done
  fi
}

function main (){
  # Generate a unique branch name
  GIT_BRANCH_NAME="Helm_Update"_$(date +"%Y%m%d")_$(echo $RANDOM | base64)
  COMMIT_MSG_FILE=$(mktemp)


  if [ -n "$UPDATE_HELM_CHART" ]; then
    if [ "$ACTIONS" = false ]; then
      git switch -c "$GIT_BRANCH_NAME" --track "$(git branch --show-current)"
    fi
    update_helm_chart "$ARGOCD_CHART_PATH/$UPDATE_HELM_CHART" "$CHART_VERSION"
  fi

  if "$UPDATE_ALL"; then
    if [ "$ACTIONS" = false ]; then
      git switch -c "$GIT_BRANCH_NAME" --track origin/master
    fi

    while read -r HELM_CHART_NAME; do
      for SKIP_HELM_CHART in "${SKIP_HELM_CHARTS[@]}"; do
        if [ "$HELM_CHART_NAME" == "$SKIP_HELM_CHART" ]; then
          echo "Skipping $SKIP_HELM_CHART"
          break
        fi
      done

      update_helm_chart "$HELM_CHART_NAME" "$CHART_VERSION"
    done < <(find ./"$ARGOCD_CHART_PATH" -maxdepth 1 -mindepth 1 -type d -exec basename {} \; | sort)

    # Determine KubeAid version bump
    CURRENT_VERSION=$(get_current_kubeaid_version)
    echo "Current KubeAid version: $CURRENT_VERSION"

    if [ "$HAS_MAJOR" = true ]; then
        BUMP_TYPE="major"
    elif [ "$HAS_MINOR" = true ]; then
        BUMP_TYPE="minor"
    elif [ "$HAS_PATCH" = true ]; then
        BUMP_TYPE="patch"
    else
      rm -f "$COMMIT_MSG_FILE"
      exit 0
    fi

    NEW_VERSION=$(bump_version "$CURRENT_VERSION" "$BUMP_TYPE")
    echo "New KubeAid version: ${GREEN}v$NEW_VERSION${NC}"

    # Generate commit message
    {
      echo "chore: update helm charts to v$NEW_VERSION"
      echo ""

      if [ ${#MAJOR_UPDATES[@]} -gt 0 ]; then
        echo "### Major Version Upgrades"
        printf '%s\n' "${MAJOR_UPDATES[@]}"
        echo ""
      fi

      if [ ${#MINOR_UPDATES[@]} -gt 0 ]; then
        echo "### Minor Version Upgrades"
        printf '%s\n' "${MINOR_UPDATES[@]}"
        echo ""
      fi

      if [ ${#PATCH_UPDATES[@]} -gt 0 ]; then
        echo "### Patch Version Upgrades"
        printf '%s\n' "${PATCH_UPDATES[@]}"
        echo ""
      fi
    } > "$COMMIT_MSG_FILE"


    if [ -n "$(git status --porcelain)" ]; then
      git add "$ARGOCD_CHART_PATH"
      git commit -F "$COMMIT_MSG_FILE"
    fi

    rm -f "$COMMIT_MSG_FILE"
  fi

  find . -name '*.tgz' -delete
}

# Run main function
main "$@"
